# Runtime

* [Как работает runtime шаблонизатора](#Как-работает-runtime-шаблонизатора)
* [Шаблоны на любые сущности](#Шаблоны-на-любые-сущности)
* [Инструкции управления](#Инструкции-управления)
  * [apply](#apply): вызвать указанный режим
  * [applyNext](#applynext): применить к узлу шаблоны с меньшим приоритетом, чем текущий
  * [applyCtx](#applyctx): применить шаблоны к произвольному BEMJSON-у

## Как работает runtime шаблонизатора

Шаблонизатор bem-xjst обладает встроенным механизмом обхода дерева входных данных. Это дерево рекурсивно обходится в прямом порядке и для каждого узла ищется подходящий шаблон.

В теле шаблона текущий узел может быть подменён на другой или дополнен новыми. В этом случае шаблонизатор попытается примерить шаблоны на все новые узлы.

Если вы не добавили ни одного шаблона, то bem-xjst сгенерирует результат по умолчанию. Это поведение [описано в разделе про режимы](5-templates-syntax.md#body).

### Как выбираются и применяются шаблоны?

Шаблоны находятся в упорядоченном списке. Шаблоны проверяются в обратном порядке, то есть последние шаблоны приоритетнее первых (с учетом особенностей [wildcard](#Шаблоны-на-любые-сущности)).

Для каждого узла входного дерева шаблонизатор проверяет предикат каждого шаблона. Для этого выполняются все подпредикаты в контексте узла. Если все подпредикаты вернули `true`, дальнейший поиск шаблона прекращается и выполняется тело текущего.

Если шаблон не найден, то будет использовано поведение по умолчанию.

## Шаблоны на любые сущности

В предикатах вы можете писать `*` вместо имени блока или элемента. Например, это может быть полезно для единообразной обработки всех блоков.

Входной BEMJSON:

```js
[
    { block: 'header' },
    { block: 'link', mix: [{ block : 'title' }], counter: '1549865' },
    { block: 'snippet', counter: '1549865' }
]
```

Шаблон:

```js
block('*')
    .match(function() { return this.ctx.counter; })({
        mix: function() {
            return { block: 'counter', js: { id: this.ctx.counter } }
        }
    })
```

*Результат шаблонизации:*

```html
<div class="header"></div>
<div class="link counter title i-bem" data-bem='{"counter":{"id":"1549865"}}'></div>
<div class="snippet counter i-bem" data-bem='{"counter":{"id":"1549865"}}'></div>
```

Шаблон с подпредикатом на `*` будет приоритетнее, чем шаблон с конкретным именем в подпредикате. Это связано с оптимизацией производительности. На практике тяжело столкнуться с ситуациями, когда это имеет значение.

Подпредикат блока на `*` будет истинным на пустой объект.

## Инструкции управления

### apply

```js
/**
 * @params {String} modeName название режима
 * @params {Object} [assignObj] объект, поля которого будут доступны
 *                              в this в теле шаблона
 * @returns {*} Возвращает результат работы режима
 */
apply(modeName, assignObj)
```

Применяется для вызова стандартного или пользовательского режима текущего узла.

```js
{ block: 'button' }
```

Шаблон:

```js
block('button')({
    test: function() {
        return this.tmp + this.ctx.foo;
    },
    default: function() {
        return apply('test', {
            tmp: 'ping',
            'ctx.foo': 'pong'
        });
    }
});
```

*Результат шаблонизации:*

```html
pingpong
```

С помощью `apply` нельзя вызывать пользовательские режимы для других блоков.

```js
// BEMJSON
[
    { block: 'header' },
    { block: 'footer' }
]
```

Шаблон:

```js
block('footer')({ custom: 'footer' });
block('header')({
    custom: 'header',
    tag: function() {
        // не смотря на то, что вторым аргументом apply явно указан блок footer
        // будет вызван пользовательский режим блока `header`.
        return apply('custom', { block: 'footer' });
    }
});
```

*Результат шаблонизации:*

```html
<header class="header"></header>
<div class="footer"></div>
```

Если будет вызван `apply()` для режима для которого нет шаблонов, то
шаблонизатор попытается извлечь значение поля с соответствующим названием из
текущего узла BEMJSON-а.

```js
// BEMJSON
{ block: 'animal', type: 'cat' }
```

Шаблон:

```js
block('animal')({
    content: function() {
        return apply('type');
    }
});
```

*Результат шаблонизации:*

```html
<div class="animal">cat</div>
```

### applyNext

```js
/**
 * @param {Object} [newctx] объект, ключи которого становятся полями
 *                          контекста при выполнении шаблона
 * @returns {*}
 */
applyNext(newctx)
```

Конструкция `applyNext` возвращает результат работы следующего по приоритету шаблона в текущем режиме для текущего узла.

**Пример**

```js
block('link')({ tag: 'a' });
block('link')({
    tag: function() {
        var res = applyNext(); // res === 'a'
        return res;
    }
});
```

### applyCtx

```js
/**
 * @param {BEMJSON} bemjson входные данные
 * @param {Object} [newctx]
 * @returns {String}
 */
applyCtx(bemjson, newctx)
```

Конструкция `applyCtx` предназначена для модификации текущего фрагмента БЭМ-дерева `this.ctx` с вызовом процедуры применения шаблонов `apply()`.

```js
{ block: 'header', mix: [{ block: 'sticky' }] }
```

Шаблон:

```js
block('header')({
    default: function() {
        return applyCtx(this.extend(this.ctx, {
            block: 'layout',
            mix: [{ block: 'header' }].concat(this.ctx.mix || [])
        }));
    }
});
```

Результат шаблонизации:

```html
<div class="layout header sticky"></div>
```
